#include "stagemedia.h"

typedef struct st_URLData {
	char	*data;
	size_t	s;
} URLData;

int	api_receive();

char	*url_fetch(const char *url, const char *post) {
	CURL	*curl;
	CURLcode	res;
	URLData		urld;

	urld.data = NULL;
	urld.s = 0;

	curl = curl_easy_init();
	
	if (!curl)
		return 0;

	curl_easy_setopt(curl, CURLOPT_URL, url);

	curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, api_receive);
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &urld);
	curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
	curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post);

	res = curl_easy_perform(curl);

	if (res != CURLE_OK) {
		fprintf(stderr, "It died :(\n");
	}

	curl_easy_cleanup(curl);
	return urld.data;
}

int	api_receive(void *ptr, size_t size, size_t num, URLData *urld) {
	int	mysize = size * num;
	char	*temp;

	temp = realloc(urld->data, urld->s + mysize + 1);
	if (temp) {
		urld->data = temp;
		memcpy(&urld->data[urld->s], ptr, mysize);
		urld->s += mysize;
		urld->data[urld->s] = '\0';
	}

	return (size * num);
}

int	request_maker() {
	int	i;
	json_t	*root, *id, *method;
	json_error_t	error;
	char	*text;
	char	post_data[8192];

	snprintf(post_data, sizeof post_data - 1, "{\"sessionid\":\"%s\",\"ip_addr\":\"%s\"}", "testing", "62.4.56.3");

	text = url_fetch("http://localhost:5001/api/v1/system/logged_cookie", post_data);

	if (!text)
		return 0;

	root = json_loads(text, 0, &error);
	if (root) {			
		if (json_is_object(root)) {
			id = json_object_get(root, "id");
			method = json_object_get(root, "method");
			if (id && method) {
				printf("id = %s, method = %s\n", json_string_value(id), json_string_value(method));
			} else {
				puts("Some kind of failure");
			}
		} else {
			puts("nope");
		}
		json_decref(root);
	} else {
		puts("Boom dead");
		return -1;
	}

	free(text);
	
	return 0;
}

void	*doit() {
	int	ec = 0;

	request_maker();
	pthread_exit(&ec);
}

//#define RUNS	100
int	main() {
	int	n;
	pthread_t	handlers[RUNS];

	for ( n = 0 ; n < RUNS; n++)
		pthread_create(&handlers[n], NULL, doit, NULL);
		
	for ( n = 0; n < RUNS; n++) {
		pthread_join(handlers[n], NULL);
	}

	return -1;
}
